项目的参数校验一般都是使用hibernate valid校验框架，但是项目中实际使用时碰到了一些，目前还没有彻底搞清楚，只是先记录一下
## @Validated ，@Valid两个注解的区别
1. @Validated是spring提供的注解，可以作用于属性、方法、对象上
2. @Valid 是hibernate原生的注解，可以作用于属性，方法上。
## spring mvc参数校验
### controller中是不是必须使用BindResult?
不是的，spring mvc的执行流程中在handlerAdapter执行handle方法中，会获取方法参数，然后执行method.invoke方法，在获取方法参数时会校验参数是否需要校验
是否需要校验的逻辑如下代码：
```
protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {
		Annotation[] annotations = parameter.getParameterAnnotations();
		for (Annotation ann : annotations) {
      // 有Validated注解或者 注解名以Valid开头(hibernate原生注解为 Valid)
			Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);
			if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith("Valid")) {
				Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));
				Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});
				binder.validate(validationHints);
				break;
			}
		}
	}
```
是否需要抛出异常的判断逻辑是当前参数后边第一个的参数是否为BindResult类型
```
protected boolean isBindExceptionRequired(WebDataBinder binder, MethodParameter parameter) {
		int i = parameter.getParameterIndex();
		Class<?>[] paramTypes = parameter.getMethod().getParameterTypes();
		boolean hasBindingResult = (paramTypes.length > (i + 1) && Errors.class.isAssignableFrom(paramTypes[i + 1]));
		return !hasBindingResult;
	}
```

整个代码的逻辑：
```
WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);
		if (arg != null) {
      // 是否需要参数校验
			validateIfApplicable(binder, parameter);
      // 如果校验不通过，并且没有BindResult类型的参数，或者BindResult参数位置不对，都直接抛异常
			if (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {
				throw new MethodArgumentNotValidException(parameter, binder.getBindingResult());
			}
		}
		mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());
```
而MethodArgumentNotValidException异常会被DefaultHandlerExceptionResolver捕获，处理方式是
```
protected ModelAndView handleMethodArgumentNotValidException(MethodArgumentNotValidException ex,
			HttpServletRequest request, HttpServletResponse response, @Nullable Object handler) throws IOException {

		response.sendError(HttpServletResponse.SC_BAD_REQUEST);
		return new ModelAndView();
	}
```
所以我们看不到异常信息，解决方法是使用@ControllerAdvice去捕获这个异常，为什么这样就可以呢，因为在DispatcherServlet.properties中定义了springmvc
异常处理器
```
org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\
	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\
	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver
```
可以看到DefaultHandlerExceptionResolver的优先级最低，而@ControllerAdvice标识的对象会使用ExceptionHandlerExceptionResolver处理。
### spring mvc 中参数校验的是用流程
1. 定义参数对象，属性上加上@NotNull等需要的注解
2. 方法参数前加上@Validated 或者 @Valid注解
3. 使用@ControllerAdvice捕获校验参数异常
## service中的参数校验
